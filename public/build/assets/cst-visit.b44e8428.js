const be=Symbol.for("yaml.alias"),We=Symbol.for("yaml.document"),J=Symbol.for("yaml.map"),Pe=Symbol.for("yaml.pair"),we=Symbol.for("yaml.scalar"),Z=Symbol.for("yaml.seq"),I=Symbol.for("yaml.node.type"),z=n=>!!n&&typeof n=="object"&&n[I]===be,v=n=>!!n&&typeof n=="object"&&n[I]===We,oe=n=>!!n&&typeof n=="object"&&n[I]===J,E=n=>!!n&&typeof n=="object"&&n[I]===Pe,A=n=>!!n&&typeof n=="object"&&n[I]===we,le=n=>!!n&&typeof n=="object"&&n[I]===Z;function N(n){if(n&&typeof n=="object")switch(n[I]){case J:case Z:return!0}return!1}function j(n){if(n&&typeof n=="object")switch(n[I]){case be:case J:case we:case Z:return!0}return!1}const ze=n=>(A(n)||N(n))&&!!n.anchor,L=Symbol("break visit"),Be=Symbol("skip children"),C=Symbol("remove node");function V(n,e){const t=Ce(e);v(n)?R(null,n.contents,t,Object.freeze([n]))===C&&(n.contents=null):R(null,n,t,Object.freeze([]))}V.BREAK=L;V.SKIP=Be;V.REMOVE=C;function R(n,e,t,s){const i=Ie(n,e,t,s);if(j(i)||E(i))return Te(n,s,i),R(n,i,t,s);if(typeof i!="symbol"){if(N(e)){s=Object.freeze(s.concat(e));for(let r=0;r<e.items.length;++r){const o=R(r,e.items[r],t,s);if(typeof o=="number")r=o-1;else{if(o===L)return L;o===C&&(e.items.splice(r,1),r-=1)}}}else if(E(e)){s=Object.freeze(s.concat(e));const r=R("key",e.key,t,s);if(r===L)return L;r===C&&(e.key=null);const o=R("value",e.value,t,s);if(o===L)return L;o===C&&(e.value=null)}}return i}async function Se(n,e){const t=Ce(e);v(n)?await U(null,n.contents,t,Object.freeze([n]))===C&&(n.contents=null):await U(null,n,t,Object.freeze([]))}Se.BREAK=L;Se.SKIP=Be;Se.REMOVE=C;async function U(n,e,t,s){const i=await Ie(n,e,t,s);if(j(i)||E(i))return Te(n,s,i),U(n,i,t,s);if(typeof i!="symbol"){if(N(e)){s=Object.freeze(s.concat(e));for(let r=0;r<e.items.length;++r){const o=await U(r,e.items[r],t,s);if(typeof o=="number")r=o-1;else{if(o===L)return L;o===C&&(e.items.splice(r,1),r-=1)}}}else if(E(e)){s=Object.freeze(s.concat(e));const r=await U("key",e.key,t,s);if(r===L)return L;r===C&&(e.key=null);const o=await U("value",e.value,t,s);if(o===L)return L;o===C&&(e.value=null)}}return i}function Ce(n){return typeof n=="object"&&(n.Collection||n.Node||n.Value)?Object.assign({Alias:n.Node,Map:n.Node,Scalar:n.Node,Seq:n.Node},n.Value&&{Map:n.Value,Scalar:n.Value,Seq:n.Value},n.Collection&&{Map:n.Collection,Seq:n.Collection},n):n}function Ie(n,e,t,s){var i,r,o,f,l;if(typeof t=="function")return t(n,e,s);if(oe(e))return(i=t.Map)==null?void 0:i.call(t,n,e,s);if(le(e))return(r=t.Seq)==null?void 0:r.call(t,n,e,s);if(E(e))return(o=t.Pair)==null?void 0:o.call(t,n,e,s);if(A(e))return(f=t.Scalar)==null?void 0:f.call(t,n,e,s);if(z(e))return(l=t.Alias)==null?void 0:l.call(t,n,e,s)}function Te(n,e,t){const s=e[e.length-1];if(N(s))s.items[n]=t;else if(E(s))n==="key"?s.key=t:s.value=t;else if(v(s))s.contents=t;else{const i=z(s)?"alias":"scalar";throw new Error(`Cannot replace node with ${i} parent`)}}const Ge={"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"},He=n=>n.replace(/[!,[\]{}]/g,e=>Ge[e]);class M{constructor(e,t){this.docStart=null,this.docEnd=!1,this.yaml=Object.assign({},M.defaultYaml,e),this.tags=Object.assign({},M.defaultTags,t)}clone(){const e=new M(this.yaml,this.tags);return e.docStart=this.docStart,e}atDocument(){const e=new M(this.yaml,this.tags);switch(this.yaml.version){case"1.1":this.atNextDocument=!0;break;case"1.2":this.atNextDocument=!1,this.yaml={explicit:M.defaultYaml.explicit,version:"1.2"},this.tags=Object.assign({},M.defaultTags);break}return e}add(e,t){this.atNextDocument&&(this.yaml={explicit:M.defaultYaml.explicit,version:"1.1"},this.tags=Object.assign({},M.defaultTags),this.atNextDocument=!1);const s=e.trim().split(/[ \t]+/),i=s.shift();switch(i){case"%TAG":{if(s.length!==2&&(t(0,"%TAG directive should contain exactly two parts"),s.length<2))return!1;const[r,o]=s;return this.tags[r]=o,!0}case"%YAML":{if(this.yaml.explicit=!0,s.length!==1)return t(0,"%YAML directive should contain exactly one part"),!1;const[r]=s;if(r==="1.1"||r==="1.2")return this.yaml.version=r,!0;{const o=/^\d+\.\d+$/.test(r);return t(6,`Unsupported YAML version ${r}`,o),!1}}default:return t(0,`Unknown directive ${i}`,!0),!1}}tagName(e,t){if(e==="!")return"!";if(e[0]!=="!")return t(`Not a valid tag: ${e}`),null;if(e[1]==="<"){const o=e.slice(2,-1);return o==="!"||o==="!!"?(t(`Verbatim tags aren't resolved, so ${e} is invalid.`),null):(e[e.length-1]!==">"&&t("Verbatim tags must end with a >"),o)}const[,s,i]=e.match(/^(.*!)([^!]*)$/);i||t(`The ${e} tag has no suffix`);const r=this.tags[s];return r?r+decodeURIComponent(i):s==="!"?e:(t(`Could not resolve tag: ${e}`),null)}tagString(e){for(const[t,s]of Object.entries(this.tags))if(e.startsWith(s))return t+He(e.substring(s.length));return e[0]==="!"?e:`!<${e}>`}toString(e){const t=this.yaml.explicit?[`%YAML ${this.yaml.version||"1.2"}`]:[],s=Object.entries(this.tags);let i;if(e&&s.length>0&&j(e.contents)){const r={};V(e.contents,(o,f)=>{j(f)&&f.tag&&(r[f.tag]=!0)}),i=Object.keys(r)}else i=[];for(const[r,o]of s)r==="!!"&&o==="tag:yaml.org,2002:"||(!e||i.some(f=>f.startsWith(o)))&&t.push(`%TAG ${r} ${o}`);return t.join(`
`)}}M.defaultYaml={explicit:!1,version:"1.2"};M.defaultTags={"!!":"tag:yaml.org,2002:"};function Ke(n){if(/[\x00-\x19\s,[\]{}]/.test(n)){const t=`Anchor must not contain whitespace or control characters: ${JSON.stringify(n)}`;throw new Error(t)}return!0}function Xe(n){const e=new Set;return V(n,{Value(t,s){s.anchor&&e.add(s.anchor)}}),e}function Ze(n,e){for(let t=1;;++t){const s=`${n}${t}`;if(!e.has(s))return s}}function mt(n,e){const t=[],s=new Map;let i=null;return{onAnchor:r=>{t.push(r),i||(i=Xe(n));const o=Ze(e,i);return i.add(o),o},setAnchors:()=>{for(const r of t){const o=s.get(r);if(typeof o=="object"&&o.anchor&&(A(o.node)||N(o.node)))o.node.anchor=o.anchor;else{const f=new Error("Failed to resolve repeated object (this should not happen)");throw f.source=r,f}}},sourceObjects:s}}function G(n,e,t,s){if(s&&typeof s=="object")if(Array.isArray(s))for(let i=0,r=s.length;i<r;++i){const o=s[i],f=G(n,s,String(i),o);f===void 0?delete s[i]:f!==o&&(s[i]=f)}else if(s instanceof Map)for(const i of Array.from(s.keys())){const r=s.get(i),o=G(n,s,i,r);o===void 0?s.delete(i):o!==r&&s.set(i,o)}else if(s instanceof Set)for(const i of Array.from(s)){const r=G(n,s,i,i);r===void 0?s.delete(i):r!==i&&(s.delete(i),s.add(r))}else for(const[i,r]of Object.entries(s)){const o=G(n,s,i,r);o===void 0?delete s[i]:o!==r&&(s[i]=o)}return n.call(e,t,s)}function P(n,e,t){if(Array.isArray(n))return n.map((s,i)=>P(s,String(i),t));if(n&&typeof n.toJSON=="function"){if(!t||!ze(n))return n.toJSON(e,t);const s={aliasCount:0,count:1,res:void 0};t.anchors.set(n,s),t.onCreate=r=>{s.res=r,delete t.onCreate};const i=n.toJSON(e,t);return t.onCreate&&t.onCreate(i),i}return typeof n=="bigint"&&!(t!=null&&t.keep)?Number(n):n}class Oe{constructor(e){Object.defineProperty(this,I,{value:e})}clone(){const e=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return this.range&&(e.range=this.range.slice()),e}toJS(e,{mapAsMap:t,maxAliasCount:s,onAnchor:i,reviver:r}={}){if(!v(e))throw new TypeError("A document argument is required");const o={anchors:new Map,doc:e,keep:!0,mapAsMap:t===!0,mapKeyWarned:!1,maxAliasCount:typeof s=="number"?s:100},f=P(this,"",o);if(typeof i=="function")for(const{count:l,res:a}of o.anchors.values())i(a,l);return typeof r=="function"?G(r,{"":f},"",f):f}}class ve extends Oe{constructor(e){super(be),this.source=e,Object.defineProperty(this,"tag",{set(){throw new Error("Alias nodes cannot have tags")}})}resolve(e){let t;return V(e,{Node:(s,i)=>{if(i===this)return V.BREAK;i.anchor===this.source&&(t=i)}}),t}toJSON(e,t){if(!t)return{source:this.source};const{anchors:s,doc:i,maxAliasCount:r}=t,o=this.resolve(i);if(!o){const l=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new ReferenceError(l)}let f=s.get(o);if(f||(P(o,null,t),f=s.get(o)),!f||f.res===void 0){const l="This should not happen: Alias anchor was not resolved?";throw new ReferenceError(l)}if(r>=0&&(f.count+=1,f.aliasCount===0&&(f.aliasCount=ee(i,o,s)),f.count*f.aliasCount>r)){const l="Excessive alias count indicates a resource exhaustion attack";throw new ReferenceError(l)}return f.res}toString(e,t,s){const i=`*${this.source}`;if(e){if(Ke(this.source),e.options.verifyAliasOrder&&!e.anchors.has(this.source)){const r=`Unresolved alias (the anchor must be set before the alias): ${this.source}`;throw new Error(r)}if(e.implicitKey)return`${i} `}return i}}function ee(n,e,t){if(z(e)){const s=e.resolve(n),i=t&&s&&t.get(s);return i?i.count*i.aliasCount:0}else if(N(e)){let s=0;for(const i of e.items){const r=ee(n,i,t);r>s&&(s=r)}return s}else if(E(e)){const s=ee(n,e.key,t),i=ee(n,e.value,t);return Math.max(s,i)}return 1}const De=n=>!n||typeof n!="function"&&typeof n!="object";class $ extends Oe{constructor(e){super(we),this.value=e}toJSON(e,t){return t!=null&&t.keep?this.value:P(this.value,e,t)}toString(){return String(this.value)}}$.BLOCK_FOLDED="BLOCK_FOLDED";$.BLOCK_LITERAL="BLOCK_LITERAL";$.PLAIN="PLAIN";$.QUOTE_DOUBLE="QUOTE_DOUBLE";$.QUOTE_SINGLE="QUOTE_SINGLE";const xe="tag:yaml.org,2002:";function et(n,e,t){var s;if(e){const i=t.filter(o=>o.tag===e),r=(s=i.find(o=>!o.format))!=null?s:i[0];if(!r)throw new Error(`Tag ${e} not found`);return r}return t.find(i=>{var r;return((r=i.identify)==null?void 0:r.call(i,n))&&!i.format})}function se(n,e,t){var g,h,c;if(v(n)&&(n=n.contents),j(n))return n;if(E(n)){const p=(h=(g=t.schema[J]).createNode)==null?void 0:h.call(g,t.schema,null,t);return p.items.push(n),p}(n instanceof String||n instanceof Number||n instanceof Boolean||typeof BigInt<"u"&&n instanceof BigInt)&&(n=n.valueOf());const{aliasDuplicateObjects:s,onAnchor:i,onTagObj:r,schema:o,sourceObjects:f}=t;let l;if(s&&n&&typeof n=="object"){if(l=f.get(n),l)return l.anchor||(l.anchor=i(n)),new ve(l.anchor);l={anchor:null,node:null},f.set(n,l)}e!=null&&e.startsWith("!!")&&(e=xe+e.slice(2));let a=et(n,e,o.tags);if(!a){if(n&&typeof n.toJSON=="function"&&(n=n.toJSON()),!n||typeof n!="object"){const p=new $(n);return l&&(l.node=p),p}a=n instanceof Map?o[J]:Symbol.iterator in Object(n)?o[Z]:o[J]}r&&(r(a),delete t.onTagObj);const y=a!=null&&a.createNode?a.createNode(t.schema,n,t):typeof((c=a==null?void 0:a.nodeClass)==null?void 0:c.from)=="function"?a.nodeClass.from(t.schema,n,t):new $(n);return e?y.tag=e:a.default||(y.tag=a.tag),l&&(l.node=y),y}function Ne(n,e,t){let s=t;for(let i=e.length-1;i>=0;--i){const r=e[i];if(typeof r=="number"&&Number.isInteger(r)&&r>=0){const o=[];o[r]=s,s=o}else s=new Map([[r,s]])}return se(s,void 0,{aliasDuplicateObjects:!1,keepUndefined:!1,onAnchor:()=>{throw new Error("This should not happen, please report a bug.")},schema:n,sourceObjects:new Map})}const tt=n=>n==null||typeof n=="object"&&!!n[Symbol.iterator]().next().done;class fe extends Oe{constructor(e,t){super(e),Object.defineProperty(this,"schema",{value:t,configurable:!0,enumerable:!1,writable:!0})}clone(e){const t=Object.create(Object.getPrototypeOf(this),Object.getOwnPropertyDescriptors(this));return e&&(t.schema=e),t.items=t.items.map(s=>j(s)||E(s)?s.clone(e):s),this.range&&(t.range=this.range.slice()),t}addIn(e,t){if(tt(e))this.add(t);else{const[s,...i]=e,r=this.get(s,!0);if(N(r))r.addIn(i,t);else if(r===void 0&&this.schema)this.set(s,Ne(this.schema,i,t));else throw new Error(`Expected YAML collection at ${s}. Remaining path: ${i}`)}}deleteIn(e){const[t,...s]=e;if(s.length===0)return this.delete(t);const i=this.get(t,!0);if(N(i))return i.deleteIn(s);throw new Error(`Expected YAML collection at ${t}. Remaining path: ${s}`)}getIn(e,t){const[s,...i]=e,r=this.get(s,!0);return i.length===0?!t&&A(r)?r.value:r:N(r)?r.getIn(i,t):void 0}hasAllNullValues(e){return this.items.every(t=>{if(!E(t))return!1;const s=t.value;return s==null||e&&A(s)&&s.value==null&&!s.commentBefore&&!s.comment&&!s.tag})}hasIn(e){const[t,...s]=e;if(s.length===0)return this.has(t);const i=this.get(t,!0);return N(i)?i.hasIn(s):!1}setIn(e,t){const[s,...i]=e;if(i.length===0)this.set(s,t);else{const r=this.get(s,!0);if(N(r))r.setIn(i,t);else if(r===void 0&&this.schema)this.set(s,Ne(this.schema,i,t));else throw new Error(`Expected YAML collection at ${s}. Remaining path: ${i}`)}}}fe.maxFlowStringSingleLineLength=60;const nt=n=>n.replace(/^(?!$)(?: $)?/gm,"#");function X(n,e){return/^\n+$/.test(n)?n.substring(1):e?n.replace(/^(?! *$)/gm,e):n}const D=(n,e,t)=>n.endsWith(`
`)?X(t,e):t.includes(`
`)?`
`+X(t,e):(n.endsWith(" ")?"":" ")+t,Fe="flow",ge="block",te="quoted";function ae(n,e,t="flow",{indentAtStart:s,lineWidth:i=80,minContentWidth:r=20,onFold:o,onOverflow:f}={}){if(!i||i<0)return n;const l=Math.max(1+r,1+i-e.length);if(n.length<=l)return n;const a=[],y={};let g=i-e.length;typeof s=="number"&&(s>i-Math.max(2,r)?a.push(0):g=i-s);let h,c,p=!1,u=-1,d=-1,S=-1;t===ge&&(u=Le(n,u),u!==-1&&(g=u+l));for(let b;b=n[u+=1];){if(t===te&&b==="\\"){switch(d=u,n[u+1]){case"x":u+=3;break;case"u":u+=5;break;case"U":u+=9;break;default:u+=1}S=u}if(b===`
`)t===ge&&(u=Le(n,u)),g=u+l,h=void 0;else{if(b===" "&&c&&c!==" "&&c!==`
`&&c!=="	"){const w=n[u+1];w&&w!==" "&&w!==`
`&&w!=="	"&&(h=u)}if(u>=g)if(h)a.push(h),g=h+l,h=void 0;else if(t===te){for(;c===" "||c==="	";)c=b,b=n[u+=1],p=!0;const w=u>S+1?u-2:d-1;if(y[w])return n;a.push(w),y[w]=!0,g=w+l,h=void 0}else p=!0}c=b}if(p&&f&&f(),a.length===0)return n;o&&o();let m=n.slice(0,a[0]);for(let b=0;b<a.length;++b){const w=a[b],O=a[b+1]||n.length;w===0?m=`
${e}${n.slice(0,O)}`:(t===te&&y[w]&&(m+=`${n[w]}\\`),m+=`
${e}${n.slice(w+1,O)}`)}return m}function Le(n,e){let t=n[e+1];for(;t===" "||t==="	";){do t=n[e+=1];while(t&&t!==`
`);t=n[e+1]}return e}const ce=(n,e)=>({indentAtStart:e?n.indent.length:n.indentAtStart,lineWidth:n.options.lineWidth,minContentWidth:n.options.minContentWidth}),ue=n=>/^(%|---|\.\.\.)/m.test(n);function st(n,e,t){if(!e||e<0)return!1;const s=e-t,i=n.length;if(i<=s)return!1;for(let r=0,o=0;r<i;++r)if(n[r]===`
`){if(r-o>s)return!0;if(o=r+1,i-o<=s)return!1}return!0}function H(n,e){const t=JSON.stringify(n);if(e.options.doubleQuotedAsJSON)return t;const{implicitKey:s}=e,i=e.options.doubleQuotedMinMultiLineLength,r=e.indent||(ue(n)?"  ":"");let o="",f=0;for(let l=0,a=t[l];a;a=t[++l])if(a===" "&&t[l+1]==="\\"&&t[l+2]==="n"&&(o+=t.slice(f,l)+"\\ ",l+=1,f=l,a="\\"),a==="\\")switch(t[l+1]){case"u":{o+=t.slice(f,l);const y=t.substr(l+2,4);switch(y){case"0000":o+="\\0";break;case"0007":o+="\\a";break;case"000b":o+="\\v";break;case"001b":o+="\\e";break;case"0085":o+="\\N";break;case"00a0":o+="\\_";break;case"2028":o+="\\L";break;case"2029":o+="\\P";break;default:y.substr(0,2)==="00"?o+="\\x"+y.substr(2):o+=t.substr(l,6)}l+=5,f=l+1}break;case"n":if(s||t[l+2]==='"'||t.length<i)l+=1;else{for(o+=t.slice(f,l)+`

`;t[l+2]==="\\"&&t[l+3]==="n"&&t[l+4]!=='"';)o+=`
`,l+=2;o+=r,t[l+2]===" "&&(o+="\\"),l+=1,f=l+1}break;default:l+=1}return o=f?o+t.slice(f):t,s?o:ae(o,r,te,ce(e,!1))}function pe(n,e){if(e.options.singleQuote===!1||e.implicitKey&&n.includes(`
`)||/[ \t]\n|\n[ \t]/.test(n))return H(n,e);const t=e.indent||(ue(n)?"  ":""),s="'"+n.replace(/'/g,"''").replace(/\n+/g,`$&
${t}`)+"'";return e.implicitKey?s:ae(s,t,Fe,ce(e,!1))}function Q(n,e){const{singleQuote:t}=e.options;let s;if(t===!1)s=H;else{const i=n.includes('"'),r=n.includes("'");i&&!r?s=pe:r&&!i?s=H:s=t?pe:H}return s(n,e)}let me;try{me=new RegExp(`(^|(?<!
))
+(?!
|$)`,"g")}catch{me=/\n+(?!\n|$)/g}function ne({comment:n,type:e,value:t},s,i,r){const{blockQuote:o,commentString:f,lineWidth:l}=s.options;if(!o||/\n[\t ]+$/.test(t)||/^\s*$/.test(t))return Q(t,s);const a=s.indent||(s.forceBlockIndent||ue(t)?"  ":""),y=o==="literal"?!0:o==="folded"||e===$.BLOCK_FOLDED?!1:e===$.BLOCK_LITERAL?!0:!st(t,l,a.length);if(!t)return y?`|
`:`>
`;let g,h;for(h=t.length;h>0;--h){const k=t[h-1];if(k!==`
`&&k!=="	"&&k!==" ")break}let c=t.substring(h);const p=c.indexOf(`
`);p===-1?g="-":t===c||p!==c.length-1?(g="+",r&&r()):g="",c&&(t=t.slice(0,-c.length),c[c.length-1]===`
`&&(c=c.slice(0,-1)),c=c.replace(me,`$&${a}`));let u=!1,d,S=-1;for(d=0;d<t.length;++d){const k=t[d];if(k===" ")u=!0;else if(k===`
`)S=d;else break}let m=t.substring(0,S<d?S+1:d);m&&(t=t.substring(m.length),m=m.replace(/\n+/g,`$&${a}`));let w=(y?"|":">")+(u?a?"2":"1":"")+g;if(n&&(w+=" "+f(n.replace(/ ?[\r\n]+/g," ")),i&&i()),y)return t=t.replace(/\n+/g,`$&${a}`),`${w}
${a}${m}${t}${c}`;t=t.replace(/\n+/g,`
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,"$1$2").replace(/\n+/g,`$&${a}`);const O=ae(`${m}${t}${c}`,a,ge,ce(s,!0));return`${w}
${a}${O}`}function it(n,e,t,s){const{type:i,value:r}=n,{actualString:o,implicitKey:f,indent:l,indentStep:a,inFlow:y}=e;if(f&&/[\n[\]{},]/.test(r)||y&&/[[\]{},]/.test(r))return Q(r,e);if(!r||/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(r))return f||y||!r.includes(`
`)?Q(r,e):ne(n,e,t,s);if(!f&&!y&&i!==$.PLAIN&&r.includes(`
`))return ne(n,e,t,s);if(ue(r)){if(l==="")return e.forceBlockIndent=!0,ne(n,e,t,s);if(f&&l===a)return Q(r,e)}const g=r.replace(/\n+/g,`$&
${l}`);if(o){const h=u=>{var d;return u.default&&u.tag!=="tag:yaml.org,2002:str"&&((d=u.test)==null?void 0:d.test(g))},{compat:c,tags:p}=e.doc.schema;if(p.some(h)||(c==null?void 0:c.some(h)))return Q(r,e)}return f?g:ae(g,l,Fe,ce(e,!1))}function rt(n,e,t,s){const{implicitKey:i,inFlow:r}=e,o=typeof n.value=="string"?n:Object.assign({},n,{value:String(n.value)});let{type:f}=n;f!==$.QUOTE_DOUBLE&&/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value)&&(f=$.QUOTE_DOUBLE);const l=y=>{switch(y){case $.BLOCK_FOLDED:case $.BLOCK_LITERAL:return i||r?Q(o.value,e):ne(o,e,t,s);case $.QUOTE_DOUBLE:return H(o.value,e);case $.QUOTE_SINGLE:return pe(o.value,e);case $.PLAIN:return it(o,e,t,s);default:return null}};let a=l(f);if(a===null){const{defaultKeyType:y,defaultStringType:g}=e.options,h=i&&y||g;if(a=l(h),a===null)throw new Error(`Unsupported default string type ${h}`)}return a}function ot(n,e){const t=Object.assign({blockQuote:!0,commentString:nt,defaultKeyType:null,defaultStringType:"PLAIN",directives:null,doubleQuotedAsJSON:!1,doubleQuotedMinMultiLineLength:40,falseStr:"false",flowCollectionPadding:!0,indentSeq:!0,lineWidth:80,minContentWidth:20,nullStr:"null",simpleKeys:!1,singleQuote:null,trueStr:"true",verifyAliasOrder:!0},n.schema.toStringOptions,e);let s;switch(t.collectionStyle){case"block":s=!1;break;case"flow":s=!0;break;default:s=null}return{anchors:new Set,doc:n,flowCollectionPadding:t.flowCollectionPadding?" ":"",indent:"",indentStep:typeof t.indent=="number"?" ".repeat(t.indent):"  ",inFlow:s,options:t}}function lt(n,e){var i,r,o,f;if(e.tag){const l=n.filter(a=>a.tag===e.tag);if(l.length>0)return(i=l.find(a=>a.format===e.format))!=null?i:l[0]}let t,s;if(A(e)){s=e.value;const l=n.filter(a=>{var y;return(y=a.identify)==null?void 0:y.call(a,s)});t=(r=l.find(a=>a.format===e.format))!=null?r:l.find(a=>!a.format)}else s=e,t=n.find(l=>l.nodeClass&&s instanceof l.nodeClass);if(!t){const l=(f=(o=s==null?void 0:s.constructor)==null?void 0:o.name)!=null?f:typeof s;throw new Error(`Tag not resolved for ${l} value`)}return t}function ft(n,e,{anchors:t,doc:s}){if(!s.directives)return"";const i=[],r=(A(n)||N(n))&&n.anchor;r&&Ke(r)&&(t.add(r),i.push(`&${r}`));const o=n.tag?n.tag:e.default?null:e.tag;return o&&i.push(s.directives.tagString(o)),i.join(" ")}function ie(n,e,t,s){var l,a;if(E(n))return n.toString(e,t,s);if(z(n)){if(e.doc.directives)return n.toString(e);if((l=e.resolvedAliases)!=null&&l.has(n))throw new TypeError("Cannot stringify circular structure without alias nodes");e.resolvedAliases?e.resolvedAliases.add(n):e.resolvedAliases=new Set([n]),n=n.resolve(e.doc)}let i;const r=j(n)?n:e.doc.createNode(n,{onTagObj:y=>i=y});i||(i=lt(e.doc.schema.tags,r));const o=ft(r,i,e);o.length>0&&(e.indentAtStart=((a=e.indentAtStart)!=null?a:0)+o.length+1);const f=typeof i.stringify=="function"?i.stringify(r,e,t,s):A(r)?rt(r,e,t,s):r.toString(e,t,s);return o?A(r)||f[0]==="{"||f[0]==="["?`${o} ${f}`:`${o}
${e.indent}${f}`:f}function at({key:n,value:e},t,s,i){var Ee,Ae;const{allNullValues:r,doc:o,indent:f,indentStep:l,options:{commentString:a,indentSeq:y,simpleKeys:g}}=t;let h=j(n)&&n.comment||null;if(g){if(h)throw new Error("With simple keys, key nodes cannot have comments");if(N(n)){const T="With simple keys, collection cannot be used as a key value";throw new Error(T)}}let c=!g&&(!n||h&&e==null&&!t.inFlow||N(n)||(A(n)?n.type===$.BLOCK_FOLDED||n.type===$.BLOCK_LITERAL:typeof n=="object"));t=Object.assign({},t,{allNullValues:!1,implicitKey:!c&&(g||!r),indent:f+l});let p=!1,u=!1,d=ie(n,t,()=>p=!0,()=>u=!0);if(!c&&!t.inFlow&&d.length>1024){if(g)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");c=!0}if(t.inFlow){if(r||e==null)return p&&s&&s(),d===""?"?":c?`? ${d}`:d}else if(r&&!g||e==null&&c)return d=`? ${d}`,h&&!p?d+=D(d,t.indent,a(h)):u&&i&&i(),d;p&&(h=null),c?(h&&(d+=D(d,t.indent,a(h))),d=`? ${d}
${f}:`):(d=`${d}:`,h&&(d+=D(d,t.indent,a(h))));let S,m,b;j(e)?(S=!!e.spaceBefore,m=e.commentBefore,b=e.comment):(S=!1,m=null,b=null,e&&typeof e=="object"&&(e=o.createNode(e))),t.implicitKey=!1,!c&&!h&&A(e)&&(t.indentAtStart=d.length+1),u=!1,!y&&l.length>=2&&!t.inFlow&&!c&&le(e)&&!e.flow&&!e.tag&&!e.anchor&&(t.indent=t.indent.substring(2));let w=!1;const O=ie(e,t,()=>w=!0,()=>u=!0);let k=" ";if(h||S||m){if(k=S?`
`:"",m){const T=a(m);k+=`
${X(T,t.indent)}`}O===""&&!t.inFlow?k===`
`&&(k=`

`):k+=`
${t.indent}`}else if(!c&&N(e)){const T=O[0],he=O.indexOf(`
`),ke=he!==-1,Ye=(Ae=(Ee=t.inFlow)!=null?Ee:e.flow)!=null?Ae:e.items.length===0;if(ke||!Ye){let je=!1;if(ke&&(T==="&"||T==="!")){let K=O.indexOf(" ");T==="&"&&K!==-1&&K<he&&O[K+1]==="!"&&(K=O.indexOf(" ",K+1)),(K===-1||he<K)&&(je=!0)}je||(k=`
${t.indent}`)}}else(O===""||O[0]===`
`)&&(k="");return d+=k+O,t.inFlow?w&&s&&s():b&&!w?d+=D(d,t.indent,a(b)):u&&i&&i(),d}function ct(n,e){(n==="debug"||n==="warn")&&(typeof process<"u"&&process.emitWarning?process.emitWarning(e):console.warn(e))}const Me="<<";function Je(n,e,{key:t,value:s}){if((n==null?void 0:n.doc.schema.merge)&&ut(t))if(s=z(s)?s.resolve(n.doc):s,le(s))for(const i of s.items)de(n,e,i);else if(Array.isArray(s))for(const i of s)de(n,e,i);else de(n,e,s);else{const i=P(t,"",n);if(e instanceof Map)e.set(i,P(s,i,n));else if(e instanceof Set)e.add(i);else{const r=ht(t,i,n),o=P(s,r,n);r in e?Object.defineProperty(e,r,{value:o,writable:!0,enumerable:!0,configurable:!0}):e[r]=o}}return e}const ut=n=>n===Me||A(n)&&n.value===Me&&(!n.type||n.type===$.PLAIN);function de(n,e,t){const s=n&&z(t)?t.resolve(n.doc):t;if(!oe(s))throw new Error("Merge sources must be maps or map aliases");const i=s.toJSON(null,n,Map);for(const[r,o]of i)e instanceof Map?e.has(r)||e.set(r,o):e instanceof Set?e.add(r):Object.prototype.hasOwnProperty.call(e,r)||Object.defineProperty(e,r,{value:o,writable:!0,enumerable:!0,configurable:!0});return e}function ht(n,e,t){if(e===null)return"";if(typeof e!="object")return String(e);if(j(n)&&t&&t.doc){const s=ot(t.doc,{});s.anchors=new Set;for(const r of t.anchors.keys())s.anchors.add(r.anchor);s.inFlow=!0,s.inStringifyKey=!0;const i=n.toString(s);if(!t.mapKeyWarned){let r=JSON.stringify(i);r.length>40&&(r=r.substring(0,36)+'..."'),ct(t.doc.options.logLevel,`Keys with collection values will be stringified due to JS Object restrictions: ${r}. Set mapAsMap: true to use object keys.`),t.mapKeyWarned=!0}return i}return JSON.stringify(e)}function $e(n,e,t){const s=se(n,void 0,t),i=se(e,void 0,t);return new B(s,i)}class B{constructor(e,t=null){Object.defineProperty(this,I,{value:Pe}),this.key=e,this.value=t}clone(e){let{key:t,value:s}=this;return j(t)&&(t=t.clone(e)),j(s)&&(s=s.clone(e)),new B(t,s)}toJSON(e,t){const s=t!=null&&t.mapAsMap?new Map:{};return Je(t,s,this)}toString(e,t,s){return e!=null&&e.doc?at(this,e,t,s):JSON.stringify(this)}}function Ve(n,e,t){var r;return(((r=e.inFlow)!=null?r:n.flow)?gt:dt)(n,e,t)}function dt({comment:n,items:e},t,{blockItemPrefix:s,flowChars:i,itemIndent:r,onChompKeep:o,onComment:f}){const{indent:l,options:{commentString:a}}=t,y=Object.assign({},t,{indent:r,type:null});let g=!1;const h=[];for(let p=0;p<e.length;++p){const u=e[p];let d=null;if(j(u))!g&&u.spaceBefore&&h.push(""),re(t,h,u.commentBefore,g),u.comment&&(d=u.comment);else if(E(u)){const m=j(u.key)?u.key:null;m&&(!g&&m.spaceBefore&&h.push(""),re(t,h,m.commentBefore,g))}g=!1;let S=ie(u,y,()=>d=null,()=>g=!0);d&&(S+=D(S,r,a(d))),g&&d&&(g=!1),h.push(s+S)}let c;if(h.length===0)c=i.start+i.end;else{c=h[0];for(let p=1;p<h.length;++p){const u=h[p];c+=u?`
${l}${u}`:`
`}}return n?(c+=`
`+X(a(n),l),f&&f()):g&&o&&o(),c}function gt({comment:n,items:e},t,{flowChars:s,itemIndent:i,onComment:r}){const{indent:o,indentStep:f,flowCollectionPadding:l,options:{commentString:a}}=t;i+=f;const y=Object.assign({},t,{indent:i,inFlow:!0,type:null});let g=!1,h=0;const c=[];for(let S=0;S<e.length;++S){const m=e[S];let b=null;if(j(m))m.spaceBefore&&c.push(""),re(t,c,m.commentBefore,!1),m.comment&&(b=m.comment);else if(E(m)){const O=j(m.key)?m.key:null;O&&(O.spaceBefore&&c.push(""),re(t,c,O.commentBefore,!1),O.comment&&(g=!0));const k=j(m.value)?m.value:null;k?(k.comment&&(b=k.comment),k.commentBefore&&(g=!0)):m.value==null&&O&&O.comment&&(b=O.comment)}b&&(g=!0);let w=ie(m,y,()=>b=null);S<e.length-1&&(w+=","),b&&(w+=D(w,i,a(b))),!g&&(c.length>h||w.includes(`
`))&&(g=!0),c.push(w),h=c.length}let p;const{start:u,end:d}=s;if(c.length===0)p=u+d;else if(g||(g=c.reduce((m,b)=>m+b.length+2,2)>fe.maxFlowStringSingleLineLength),g){p=u;for(const S of c)p+=S?`
${f}${o}${S}`:`
`;p+=`
${o}${d}`}else p=`${u}${l}${c.join(" ")}${l}${d}`;return n&&(p+=D(p,o,a(n)),r&&r()),p}function re({indent:n,options:{commentString:e}},t,s,i){if(s&&i&&(s=s.replace(/^\n+/,"")),s){const r=X(e(s),n);t.push(r.trimStart())}}function F(n,e){const t=A(e)?e.value:e;for(const s of n)if(E(s)&&(s.key===e||s.key===t||A(s.key)&&s.key.value===t))return s}class _ extends fe{static get tagName(){return"tag:yaml.org,2002:map"}constructor(e){super(J,e),this.items=[]}static from(e,t,s){const{keepUndefined:i,replacer:r}=s,o=new this(e),f=(l,a)=>{if(typeof r=="function")a=r.call(t,l,a);else if(Array.isArray(r)&&!r.includes(l))return;(a!==void 0||i)&&o.items.push($e(l,a,s))};if(t instanceof Map)for(const[l,a]of t)f(l,a);else if(t&&typeof t=="object")for(const l of Object.keys(t))f(l,t[l]);return typeof e.sortMapEntries=="function"&&o.items.sort(e.sortMapEntries),o}add(e,t){var o;let s;E(e)?s=e:!e||typeof e!="object"||!("key"in e)?s=new B(e,e==null?void 0:e.value):s=new B(e.key,e.value);const i=F(this.items,s.key),r=(o=this.schema)==null?void 0:o.sortMapEntries;if(i){if(!t)throw new Error(`Key ${s.key} already set`);A(i.value)&&De(s.value)?i.value.value=s.value:i.value=s.value}else if(r){const f=this.items.findIndex(l=>r(s,l)<0);f===-1?this.items.push(s):this.items.splice(f,0,s)}else this.items.push(s)}delete(e){const t=F(this.items,e);return t?this.items.splice(this.items.indexOf(t),1).length>0:!1}get(e,t){var r;const s=F(this.items,e),i=s==null?void 0:s.value;return(r=!t&&A(i)?i.value:i)!=null?r:void 0}has(e){return!!F(this.items,e)}set(e,t){this.add(new B(e,t),!0)}toJSON(e,t,s){const i=s?new s:t!=null&&t.mapAsMap?new Map:{};t!=null&&t.onCreate&&t.onCreate(i);for(const r of this.items)Je(t,i,r);return i}toString(e,t,s){if(!e)return JSON.stringify(this);for(const i of this.items)if(!E(i))throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);return!e.allNullValues&&this.hasAllNullValues(!1)&&(e=Object.assign({},e,{allNullValues:!0})),Ve(this,e,{blockItemPrefix:"",flowChars:{start:"{",end:"}"},itemIndent:e.indent||"",onChompKeep:s,onComment:t})}}class _e extends fe{static get tagName(){return"tag:yaml.org,2002:seq"}constructor(e){super(Z,e),this.items=[]}add(e){this.items.push(e)}delete(e){const t=x(e);return typeof t!="number"?!1:this.items.splice(t,1).length>0}get(e,t){const s=x(e);if(typeof s!="number")return;const i=this.items[s];return!t&&A(i)?i.value:i}has(e){const t=x(e);return typeof t=="number"&&t<this.items.length}set(e,t){const s=x(e);if(typeof s!="number")throw new Error(`Expected a valid index, not ${e}.`);const i=this.items[s];A(i)&&De(t)?i.value=t:this.items[s]=t}toJSON(e,t){const s=[];t!=null&&t.onCreate&&t.onCreate(s);let i=0;for(const r of this.items)s.push(P(r,String(i++),t));return s}toString(e,t,s){return e?Ve(this,e,{blockItemPrefix:"- ",flowChars:{start:"[",end:"]"},itemIndent:(e.indent||"")+"  ",onChompKeep:s,onComment:t}):JSON.stringify(this)}static from(e,t,s){const{replacer:i}=s,r=new this(e);if(t&&Symbol.iterator in Object(t)){let o=0;for(let f of t){if(typeof i=="function"){const l=t instanceof Set?f:String(o++);f=i.call(t,l,f)}r.items.push(se(f,void 0,s))}}return r}}function x(n){let e=A(n)?n.value:n;return e&&typeof e=="string"&&(e=Number(e)),typeof e=="number"&&Number.isInteger(e)&&e>=0?e:null}function Re(n,e){var t;if(le(n))for(let s=0;s<n.items.length;++s){let i=n.items[s];if(!E(i)){if(oe(i)){i.items.length>1&&e("Each pair must have its own sequence indicator");const r=i.items[0]||new B(new $(null));if(i.commentBefore&&(r.key.commentBefore=r.key.commentBefore?`${i.commentBefore}
${r.key.commentBefore}`:i.commentBefore),i.comment){const o=(t=r.value)!=null?t:r.key;o.comment=o.comment?`${i.comment}
${o.comment}`:i.comment}i=r}n.items[s]=E(i)?i:new B(i)}}else e("Expected a sequence for this tag");return n}function Ue(n,e,t){const{replacer:s}=t,i=new _e(n);i.tag="tag:yaml.org,2002:pairs";let r=0;if(e&&Symbol.iterator in Object(e))for(let o of e){typeof s=="function"&&(o=s.call(e,String(r++),o));let f,l;if(Array.isArray(o))if(o.length===2)f=o[0],l=o[1];else throw new TypeError(`Expected [key, value] tuple: ${o}`);else if(o&&o instanceof Object){const a=Object.keys(o);if(a.length===1)f=a[0],l=o[f];else throw new TypeError(`Expected { key: value } tuple: ${o}`)}else f=o;i.items.push($e(f,l,t))}return i}const yt={collection:"seq",default:!1,tag:"tag:yaml.org,2002:pairs",resolve:Re,createNode:Ue};class q extends _e{constructor(){super(),this.add=_.prototype.add.bind(this),this.delete=_.prototype.delete.bind(this),this.get=_.prototype.get.bind(this),this.has=_.prototype.has.bind(this),this.set=_.prototype.set.bind(this),this.tag=q.tag}toJSON(e,t){if(!t)return super.toJSON(e);const s=new Map;t!=null&&t.onCreate&&t.onCreate(s);for(const i of this.items){let r,o;if(E(i)?(r=P(i.key,"",t),o=P(i.value,r,t)):r=P(i,"",t),s.has(r))throw new Error("Ordered maps must not include duplicate keys");s.set(r,o)}return s}static from(e,t,s){const i=Ue(e,t,s),r=new this;return r.items=i.items,r}}q.tag="tag:yaml.org,2002:omap";const bt={collection:"seq",identify:n=>n instanceof Map,nodeClass:q,default:!1,tag:"tag:yaml.org,2002:omap",resolve(n,e){const t=Re(n,e),s=[];for(const{key:i}of t.items)A(i)&&(s.includes(i.value)?e(`Ordered maps must not include duplicate keys: ${i.value}`):s.push(i.value));return Object.assign(new q,t)},createNode:(n,e,t)=>q.from(n,e,t)};class Y extends _{constructor(e){super(e),this.tag=Y.tag}add(e){let t;E(e)?t=e:e&&typeof e=="object"&&"key"in e&&"value"in e&&e.value===null?t=new B(e.key,null):t=new B(e,null),F(this.items,t.key)||this.items.push(t)}get(e,t){const s=F(this.items,e);return!t&&E(s)?A(s.key)?s.key.value:s.key:s}set(e,t){if(typeof t!="boolean")throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof t}`);const s=F(this.items,e);s&&!t?this.items.splice(this.items.indexOf(s),1):!s&&t&&this.items.push(new B(e))}toJSON(e,t){return super.toJSON(e,t,Set)}toString(e,t,s){if(!e)return JSON.stringify(this);if(this.hasAllNullValues(!0))return super.toString(Object.assign({},e,{allNullValues:!0}),t,s);throw new Error("Set items must all have null values")}static from(e,t,s){const{replacer:i}=s,r=new this(e);if(t&&Symbol.iterator in Object(t))for(let o of t)typeof i=="function"&&(o=i.call(t,o,o)),r.items.push($e(o,null,s));return r}}Y.tag="tag:yaml.org,2002:set";const wt={collection:"map",identify:n=>n instanceof Set,nodeClass:Y,default:!1,tag:"tag:yaml.org,2002:set",createNode:(n,e,t)=>Y.from(n,e,t),resolve(n,e){if(oe(n)){if(n.hasAllNullValues(!0))return Object.assign(new Y,n);e("Set items must all have null values")}else e("Expected a mapping for this tag");return n}},ye=Symbol("break visit"),pt=Symbol("skip children"),Qe=Symbol("remove item");function W(n,e){"type"in n&&n.type==="document"&&(n={start:n.start,value:n.value}),qe(Object.freeze([]),n,e)}W.BREAK=ye;W.SKIP=pt;W.REMOVE=Qe;W.itemAtPath=(n,e)=>{let t=n;for(const[s,i]of e){const r=t==null?void 0:t[s];if(r&&"items"in r)t=r.items[i];else return}return t};W.parentCollection=(n,e)=>{const t=W.itemAtPath(n,e.slice(0,-1)),s=e[e.length-1][0],i=t==null?void 0:t[s];if(i&&"items"in i)return i;throw new Error("Parent collection not found")};function qe(n,e,t){let s=t(e,n);if(typeof s=="symbol")return s;for(const i of["key","value"]){const r=e[i];if(r&&"items"in r){for(let o=0;o<r.items.length;++o){const f=qe(Object.freeze(n.concat([[i,o]])),r.items[o],t);if(typeof f=="number")o=f-1;else{if(f===ye)return ye;f===Qe&&(r.items.splice(o,1),o-=1)}}typeof s=="function"&&i==="key"&&(s=s(e,n))}}return typeof s=="function"?s(e,n):s}export{ve as A,W as B,ct as C,We as D,z as E,v as F,V as G,Se as H,J as M,I as N,B as P,$ as S,_ as Y,_e as a,le as b,wt as c,we as d,Z as e,ot as f,X as g,j as h,oe as i,ie as j,M as k,D as l,Xe as m,Ze as n,bt as o,yt as p,se as q,N as r,rt as s,tt as t,A as u,Ne as v,P as w,G as x,mt as y,E as z};
